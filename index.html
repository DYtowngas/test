<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è§£é”æ–‡åŒ–å¯†ç æŒ‘æˆ˜èµ›</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'SimHei', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 30px;
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #4a6fa5;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #2c3e50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .game-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        
        .level-title {
            font-size: 1.5rem;
            color: #2c3e50;
            font-weight: bold;
        }
        
        .total-timer {
            font-size: 1.2rem;
            color: #4a6fa5;
            font-weight: bold;
            display: none;
        }
        
        .grid-title {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .crossword-grid {
            display: inline-block;
            border: 3px solid #2c3e50;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fff;
            margin-bottom: 30px;
        }
        
        table {
            border-collapse: collapse;
        }
        
        td {
            width: 50px;
            height: 50px;
            border: 1px solid #bdc3c7;
            text-align: center;
            vertical-align: middle;
            position: relative;
            font-size: 22px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        td:hover {
            background-color: #f8f9fa;
        }
        
        .blank-cell {
            background-color: #f5f5f5;
            border-color: #e0e0e0;
        }
        
        .input-cell {
            cursor: pointer;
        }
        
        .input-cell.selected {
            background-color: #e8f4fd !important;
            box-shadow: inset 0 0 0 2px #1e88e5;
        }
        
        .input-cell.filled {
            background-color: #f0f8ff;
        }
        
        .preset-cell {
            background-color: #e8f4fd;
            color: #1e88e5;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 25px;
            padding-top: 25px;
            border-top: 1px solid #eee;
        }
        
        button {
            background-color: #4a6fa5;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 7px 14px rgba(50, 50, 93, 0.1);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        button#nextLevelBtn {
            background: linear-gradient(to right, #27ae60, #2ecc71);
            display: none;
        }
        
        button#nextLevelBtn:hover:not(:disabled) {
            background: linear-gradient(to right, #219653, #27ae60);
        }
        
        button#resetBtn {
            background: linear-gradient(to right, #e74c3c, #c0392b);
        }
        
        button#resetBtn:hover:not(:disabled) {
            background: linear-gradient(to right, #c0392b, #a93226);
        }
        
        .candidate-words {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-top: 20px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #bdc3c7;
            min-height: 80px;
            width: 100%;
        }
        
        .candidate-word {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            background-color: white;
            border: 2px solid #4a6fa5;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .candidate-word:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
            background-color: #e8f4fd;
        }
        
        .candidate-word.selected {
            background-color: #1e88e5;
            color: white;
            transform: scale(1.05);
        }
        
        .candidate-word.used {
            background-color: #f5f5f5;
            color: #bbb;
            border-color: #ddd;
            cursor: not-allowed;
        }
        
        .candidate-word.used:hover {
            transform: none;
            box-shadow: none;
            background-color: #f5f5f5;
        }
        
        .game-status {
            text-align: center;
            font-weight: bold;
            min-height: 40px;
            margin-top: 20px;
            font-size: 1.2rem;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .correct {
            background-color: #d5f4e6;
            color: #27ae60;
            border: 2px solid #27ae60;
        }
        
        .incorrect {
            background-color: #fdeaea;
            color: #e74c3c;
            border: 2px solid #e74c3c;
        }
        
        .info {
            background-color: #e8f4fd;
            color: #4a6fa5;
            border: 2px solid #4a6fa5;
        }
        
        .completion-time {
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            color: #4a6fa5;
            margin-top: 15px;
            padding: 10px;
            background-color: #e8f4fd;
            border-radius: 8px;
            display: none;
        }
        
        .instructions {
            background: linear-gradient(to right, #e8f4fd, #f0f8ff);
            border-radius: 10px;
            padding: 25px;
            margin-top: 30px;
            border-left: 5px solid #4a6fa5;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .instructions-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 600px) {
            .instructions-content {
                grid-template-columns: 1fr;
            }
        }
        
        .instructions ul {
            padding-left: 20px;
            list-style-type: none;
        }
        
        .instructions li {
            margin-bottom: 15px;
            font-size: 1.05rem;
            line-height: 1.5;
        }
        
        .instructions strong {
            color: #2c3e50;
            display: block;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        
        .instructions .instruction-item {
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 3px solid #4a6fa5;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9rem;
            padding-top: 20px;
            border-top: 1px solid #eee;
            width: 100%;
        }
        
        @media (max-width: 768px) {
            td {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .candidate-word {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }
        
        @media (max-width: 600px) {
            td {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .candidate-word {
                width: 35px;
                height: 35px;
                font-size: 18px;
            }
            
            button {
                padding: 12px 20px;
                min-width: 130px;
                font-size: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
        
        .level-indicator {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        
        .level-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: #666;
            transition: all 0.3s;
            cursor: default;
            user-select: none;
        }
        
        .level-dot.active {
            background-color: #4a6fa5;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .level-dot.completed {
            background-color: #27ae60;
            color: white;
        }
        
        @keyframes celebrate {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .celebrate {
            animation: celebrate 0.5s ease-in-out 3;
        }
        
        #leaderboard {
            margin: 0 auto;
            width: 100%;
            max-width: 800px;
            border-collapse: collapse;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #leaderboard th {
            background-color: #4a6fa5;
            color: white;
            padding: 12px;
            text-align: center;
        }
        
        #leaderboard td {
            width: auto;
            height: auto;
            padding: 10px;
            text-align: center;
            border: 1px solid #e0e0e0;
            font-size: 16px;
        }
        
        #leaderboard tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        #leaderboard tr:hover {
            background-color: #e8f4fd;
        }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4a6fa5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal {
            background-color: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
        }
        
        .modal h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .modal input {
            width: 100%;
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }
        
        .modal input:focus {
            outline: none;
            border-color: #4a6fa5;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .modal-buttons button {
            min-width: 120px;
        }
        
        #viewLeaderboardBtn {
            background: linear-gradient(to right, #9b59b6, #8e44ad);
            margin-top: 10px;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        
        #viewLeaderboardBtn:hover:not(:disabled) {
            background: linear-gradient(to right, #8e44ad, #7d3c98);
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        #setupApiKeyBtn {
            background: linear-gradient(to right, #f39c12, #e67e22);
        }
        
        .leaderboard-section {
            margin-top: 30px;
            width: 100%;
            text-align: center;
        }
        
        .leaderboard-section h3 {
            text-align: center;
        }
        
        .leaderboard-section p {
            text-align: center;
        }
        
        #refreshLeaderboardBtn, #hideLeaderboardBtn, #retryLeaderboardBtn {
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>è§£é”æ–‡åŒ–å¯†ç æŒ‘æˆ˜èµ›</h1>
        </header>
        
        <div class="level-indicator" id="levelIndicator">
            <div class="level-dot" data-level="1">1</div>
            <div class="level-dot" data-level="2">2</div>
            <div class="level-dot" data-level="3">3</div>
            <div class="level-dot" data-level="4">4</div>
        </div>
        
        <div class="game-container">
            <div class="level-info">
                <div class="level-title" id="levelTitle">ç¬¬ä¸€å…³</div>
                <div class="total-timer" id="totalTimer">æ€»ç”¨æ—¶: 00:00.000</div>
            </div>
            
            <h3 class="grid-title" id="gridTitle">è¯·ä»ä¸‹æ–¹å¤‡é€‰å­—ä¸­é€‰æ‹©å¡«å…¥ç©ºæ ¼ä¸­</h3>
            <div class="crossword-grid">
                <table id="crosswordTable">
                    <!-- ç½‘æ ¼å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </table>
            </div>
            
            <div class="candidate-words" id="candidateWords">
                <!-- å¤‡é€‰å­—å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <div class="game-status" id="gameStatus">è¯·é€‰æ‹©ç©ºæ ¼æˆ–å¤‡é€‰å­—</div>
            <div class="completion-time" id="completionTime"></div>
        </div>
        
        <div class="controls">
            <button id="nextLevelBtn">
                <span>ä¸‹ä¸€å…³</span>
            </button>
            <button id="checkBtn">
                <span>æ£€æŸ¥ç­”æ¡ˆ</span>
            </button>
            <button id="resetBtn">
                <span>é‡ç½®æœ¬å…³</span>
            </button>
        </div>
        
        <!-- æ’è¡Œæ¦œå±•ç¤ºåŒºåŸŸ - ç§»åŠ¨åˆ°æ§åˆ¶æŒ‰é’®ä¸‹æ–¹ -->
        <div class="leaderboard-section" id="leaderboardContainer">
            <!-- å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
        
        <div class="instructions">
            <h3>æ¸¸æˆè¯´æ˜</h3>
            <div class="instructions-content">
                <div>
                    <ul>
                        <li class="instruction-item">
                            <strong>æ¸¸æˆç›®æ ‡</strong>
                            æµ‹æµ‹ä½ å¯¹ä¼ä¸šæ–‡åŒ–æ ¸å¿ƒä»·å€¼è§‚çš„ç†Ÿæ‚‰åº¦ï¼Œåœ¨å°½é‡çŸ­çš„æ—¶é—´å†…å®Œæˆå››å…³å¡«å­—æ¸¸æˆï¼Œè§£é”æ–‡åŒ–å¯†ç ã€‚
                        </li>
                        <li class="instruction-item">
                            <strong>æ¸¸æˆæç¤º</strong>
                            æ‰€æœ‰å››å­—è¯å‡å‡ºè‡ªä¹å¤§æ ¸å¿ƒä»·å€¼è§‚å’Œå¸¸è§å››å­—æˆè¯­ï¼Œæ˜¯ç ´è§£å¯†ç çš„å…³é”®çº¿ç´¢ã€‚
                        </li>
                    </ul>
                </div>
                <div>
                    <ul>
                        <li class="instruction-item">
                            <strong>æ¸¸æˆè§„åˆ™</strong>
                            å°†ä¸‹æ–¹æ‰€æœ‰å¤‡é€‰å­—å¡«å…¥æ­£ç¡®ç©ºæ ¼å¤„ï¼Œå®Œæˆå¯†ç ç ´è§£æŒ‘æˆ˜ã€‚
                        </li>
                        <li class="instruction-item">
                            <strong>å…³å¡è§„åˆ™</strong>
                            å¿…é¡»å®Œæˆå½“å‰å…³å¡æ‰èƒ½è§£é”ä¸‹ä¸€å…³å¯†ç ã€‚
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <!-- ä¿®æ”¹é¡µè„šæ–‡æ¡ˆ -->
        <p>è§£é”æ–‡åŒ–å¯†ç æŒ‘æˆ˜èµ› Â© 2025 å¹¿å·ä¸œæ°¸æ¸¯åç‡ƒæ°”æœ‰é™å…¬å¸</p>
    </footer>

    <!-- æ˜µç§°è¾“å…¥å¼¹çª— -->
    <div class="modal-overlay" id="nicknameModal" style="display: none;">
        <div class="modal">
            <h3>ğŸ‰ æ­å–œå®ŒæˆæŒ‘æˆ˜ï¼</h3>
            <p style="text-align: center; margin-bottom: 20px;">è¯·è¾“å…¥æ‚¨çš„æ˜µç§°ç™»ä¸Šæ’è¡Œæ¦œï¼š</p>
            <input type="text" id="nicknameInput" placeholder="è¯·è¾“å…¥æ˜µç§° (æœ€å¤š10ä¸ªå­—ç¬¦)" maxlength="10">
            <div class="modal-buttons">
                <button id="submitScoreBtn">æäº¤æˆç»©</button>
                <button id="cancelScoreBtn" style="background-color: #95a5a6;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        // ============================
        // Airtableé…ç½®
        // ============================
        const AIRTABLE_CONFIG = {
            // ğŸ”´ å·²æ›´æ–°ä¸ºä½ æä¾›çš„API Key
            API_KEY: 'pat3Vo18ylVkIoJVz.9c8275eb2ea52d04865b200b5d7fdff92973c7e163becfb9d2685d60dacadbc0',
            BASE_ID: 'appRaFWCn8rs6fnRp',
            TABLE_NAME: 'gamerank',
            API_URL: 'https://api.airtable.com/v0'
        };

        // ============================
        // æ¸¸æˆå…³å¡æ•°æ®
        // ============================
        const gameLevels = [
            {
                level: 1,
                title: "ç¬¬ä¸€å…³",
                gridSize: { rows: 6, cols: 6 },
                
                words: [
                    {
                        id: 1,
                        name: "å®‰å…¨å¯é ",
                        direction: 'across',
                        startRow: 1,
                        startCol: 1,
                        answer: "å®‰å…¨å¯é ",
                        cells: [
                            { row: 1, col: 1, char: 'å®‰', isPreset: false },
                            { row: 1, col: 2, char: 'å…¨', isPreset: false },
                            { row: 1, col: 3, char: 'å¯', isPreset: true },
                            { row: 1, col: 4, char: 'é ', isPreset: false }
                        ]
                    },
                    {
                        id: 2,
                        name: "å…¨åŠ›ä»¥èµ´",
                        direction: 'down',
                        startRow: 1,
                        startCol: 2,
                        answer: "å…¨åŠ›ä»¥èµ´",
                        cells: [
                            { row: 1, col: 2, char: 'å…¨', isPreset: false },
                            { row: 2, col: 2, char: 'åŠ›', isPreset: true },
                            { row: 3, col: 2, char: 'ä»¥', isPreset: false },
                            { row: 4, col: 2, char: 'èµ´', isPreset: true }
                        ]
                    },
                    {
                        id: 3,
                        name: "ä»¥å®¢ä¸ºå°Š",
                        direction: 'across',
                        startRow: 3,
                        startCol: 2,
                        answer: "ä»¥å®¢ä¸ºå°Š",
                        cells: [
                            { row: 3, col: 2, char: 'ä»¥', isPreset: false },
                            { row: 3, col: 3, char: 'å®¢', isPreset: false },
                            { row: 3, col: 4, char: 'ä¸º', isPreset: true },
                            { row: 3, col: 5, char: 'å°Š', isPreset: false }
                        ]
                    },
                    {
                        id: 4,
                        name: "å°Šå¸ˆé‡é“",
                        direction: 'down',
                        startRow: 3,
                        startCol: 5,
                        answer: "å°Šå¸ˆé‡é“",
                        cells: [
                            { row: 3, col: 5, char: 'å°Š', isPreset: false },
                            { row: 4, col: 5, char: 'å¸ˆ', isPreset: false },
                            { row: 5, col: 5, char: 'é‡', isPreset: true },
                            { row: 6, col: 5, char: 'é“', isPreset: true }
                        ]
                    }
                ],
                
                candidateWords: ['å®‰', 'å…¨', 'é ', 'ä»¥', 'å®¢', 'å°Š', 'å¸ˆ']
            },
            {
                level: 2,
                title: "ç¬¬äºŒå…³",
                gridSize: { rows: 6, cols: 6 },
                
                words: [
                    {
                        id: 1,
                        name: "é¢†å¯¼æ‰èƒ½",
                        direction: 'down',
                        startRow: 1,
                        startCol: 3,
                        answer: "é¢†å¯¼æ‰èƒ½",
                        cells: [
                            { row: 1, col: 3, char: 'é¢†', isPreset: true },
                            { row: 2, col: 3, char: 'å¯¼', isPreset: false },
                            { row: 3, col: 3, char: 'æ‰', isPreset: false },
                            { row: 4, col: 3, char: 'èƒ½', isPreset: true }
                        ]
                    },
                    {
                        id: 2,
                        name: "å¤šæ‰å¤šè‰º",
                        direction: 'across',
                        startRow: 3,
                        startCol: 2,
                        answer: "å¤šæ‰å¤šè‰º",
                        cells: [
                            { row: 3, col: 2, char: 'å¤š', isPreset: false },
                            { row: 3, col: 3, char: 'æ‰', isPreset: false },
                            { row: 3, col: 4, char: 'å¤š', isPreset: true },
                            { row: 3, col: 5, char: 'è‰º', isPreset: true }
                        ]
                    },
                    {
                        id: 3,
                        name: "å¤šå…ƒæŠ€èƒ½",
                        direction: 'down',
                        startRow: 3,
                        startCol: 2,
                        answer: "å¤šå…ƒæŠ€èƒ½",
                        cells: [
                            { row: 3, col: 2, char: 'å¤š', isPreset: false },
                            { row: 4, col: 2, char: 'å…ƒ', isPreset: false },
                            { row: 5, col: 2, char: 'æŠ€', isPreset: false },
                            { row: 6, col: 2, char: 'èƒ½', isPreset: false }
                        ]
                    },
                    {
                        id: 4,
                        name: "èƒ½å·¥å·§åŒ ",
                        direction: 'across',
                        startRow: 6,
                        startCol: 2,
                        answer: "èƒ½å·¥å·§åŒ ",
                        cells: [
                            { row: 6, col: 2, char: 'èƒ½', isPreset: false },
                            { row: 6, col: 3, char: 'å·¥', isPreset: false },
                            { row: 6, col: 4, char: 'å·§', isPreset: true },
                            { row: 6, col: 5, char: 'åŒ ', isPreset: true }
                        ]
                    }
                ],
                
                candidateWords: ['å¯¼', 'æ‰', 'å¤š', 'å…ƒ', 'æŠ€', 'èƒ½', 'å·¥']
            },
            {
                level: 3,
                title: "ç¬¬ä¸‰å…³",
                gridSize: { rows: 6, cols: 6 },
                
                words: [
                    {
                        id: 1,
                        name: "å›¢ç»“å…±èµ¢",
                        direction: 'down',
                        startRow: 2,
                        startCol: 1,
                        answer: "å›¢ç»“å…±èµ¢",
                        cells: [
                            { row: 2, col: 1, char: 'å›¢', isPreset: false },
                            { row: 3, col: 1, char: 'ç»“', isPreset: true },
                            { row: 4, col: 1, char: 'å…±', isPreset: true },
                            { row: 5, col: 1, char: 'èµ¢', isPreset: false }
                        ]
                    },
                    {
                        id: 2,
                        name: "ç»“æœå¯¼å‘",
                        direction: 'across',
                        startRow: 3,
                        startCol: 1,
                        answer: "ç»“æœå¯¼å‘",
                        cells: [
                            { row: 3, col: 1, char: 'ç»“', isPreset: true },
                            { row: 3, col: 2, char: 'æœ', isPreset: false },
                            { row: 3, col: 3, char: 'å¯¼', isPreset: false },
                            { row: 3, col: 4, char: 'å‘', isPreset: true }
                        ]
                    },
                    {
                        id: 3,
                        name: "æ­£å‘æ²Ÿé€š",
                        direction: 'down',
                        startRow: 2,
                        startCol: 4,
                        answer: "æ­£å‘æ²Ÿé€š",
                        cells: [
                            { row: 2, col: 4, char: 'æ­£', isPreset: false },
                            { row: 3, col: 4, char: 'å‘', isPreset: true },
                            { row: 4, col: 4, char: 'æ²Ÿ', isPreset: false },
                            { row: 5, col: 4, char: 'é€š', isPreset: false }
                        ]
                    },
                    {
                        id: 4,
                        name: "å››é€šå…«è¾¾",
                        direction: 'across',
                        startRow: 5,
                        startCol: 3,
                        answer: "å››é€šå…«è¾¾",
                        cells: [
                            { row: 5, col: 3, char: 'å››', isPreset: false },
                            { row: 5, col: 4, char: 'é€š', isPreset: false },
                            { row: 5, col: 5, char: 'å…«', isPreset: true },
                            { row: 5, col: 6, char: 'è¾¾', isPreset: true }
                        ]
                    }
                ],
                
                candidateWords: ['å›¢', 'èµ¢', 'æœ', 'å¯¼', 'æ­£', 'æ²Ÿ', 'é€š', 'å››']
            },
            {
                level: 4,
                title: "ç¬¬å››å…³",
                gridSize: { rows: 7, cols: 7 },
                
                words: [
                    {
                        id: 1,
                        name: "æ€ç»´é©æ–°",
                        direction: 'down',
                        startRow: 3,
                        startCol: 2,
                        answer: "æ€ç»´é©æ–°",
                        cells: [
                            { row: 3, col: 2, char: 'æ€', isPreset: false },
                            { row: 4, col: 2, char: 'ç»´', isPreset: true },
                            { row: 5, col: 2, char: 'é©', isPreset: false },
                            { row: 6, col: 2, char: 'æ–°', isPreset: false }
                        ]
                    },
                    {
                        id: 2,
                        name: "æ—¥æ–°æœˆå¼‚",
                        direction: 'across',
                        startRow: 6,
                        startCol: 1,
                        answer: "æ—¥æ–°æœˆå¼‚",
                        cells: [
                            { row: 6, col: 1, char: 'æ—¥', isPreset: true },
                            { row: 6, col: 2, char: 'æ–°', isPreset: false },
                            { row: 6, col: 3, char: 'æœˆ', isPreset: false },
                            { row: 6, col: 4, char: 'å¼‚', isPreset: true }
                        ]
                    },
                    {
                        id: 3,
                        name: "å¤§åŒå°å¼‚",
                        direction: 'down',
                        startRow: 3,
                        startCol: 4,
                        answer: "å¤§åŒå°å¼‚",
                        cells: [
                            { row: 3, col: 4, char: 'å¤§', isPreset: false },
                            { row: 4, col: 4, char: 'åŒ', isPreset: false },
                            { row: 5, col: 4, char: 'å°', isPreset: true },
                            { row: 6, col: 4, char: 'å¼‚', isPreset: true }
                        ]
                    },
                    {
                        id: 4,
                        name: "ä¸€è§†åŒä»",
                        direction: 'down',
                        startRow: 2,
                        startCol: 6,
                        answer: "ä¸€è§†åŒä»",
                        cells: [
                            { row: 2, col: 6, char: 'ä¸€', isPreset: false },
                            { row: 3, col: 6, char: 'è§†', isPreset: false },
                            { row: 4, col: 6, char: 'åŒ', isPreset: true },
                            { row: 5, col: 6, char: 'ä»', isPreset: true }
                        ]
                    },
                    {
                        id: 5,
                        name: "å¤§å±€è§†é‡",
                        direction: 'across',
                        startRow: 3,
                        startCol: 4,
                        answer: "å¤§å±€è§†é‡",
                        cells: [
                            { row: 3, col: 4, char: 'å¤§', isPreset: false },
                            { row: 3, col: 5, char: 'å±€', isPreset: false },
                            { row: 3, col: 6, char: 'è§†', isPreset: false },
                            { row: 3, col: 7, char: 'é‡', isPreset: false }
                        ]
                    }
                ],
                
                candidateWords: ['æ€', 'é©', 'æ–°', 'æœˆ', 'å¤§', 'å±€', 'è§†', 'é‡', 'ä¸€', 'åŒ']
            }
        ];

        // ============================
        // æ¸¸æˆçŠ¶æ€ï¼ˆä¿®å¤è®¡æ—¶å™¨æ˜¾ç¤ºé—®é¢˜ï¼‰
        // ============================
        const gameState = {
            currentLevel: 0,
            levelsCompleted: 0,
            gameStarted: false,
            gameEnded: false,
            startTime: null,
            endTime: null,
            timerInterval: null, // æ”¹å›ä½¿ç”¨setInterval
            totalMilliseconds: 0,
            
            currentGrid: [],
            userAnswers: {},
            filledCells: 0,
            totalCells: 0,
            selectedCell: null,
            selectedCandidate: null,
            usedCandidates: new Set(),
            candidateToCell: new Map(),
            shuffledCandidates: [],
            
            init: function(levelIndex) {
                this.currentLevel = levelIndex;
                const levelData = gameLevels[levelIndex];
                
                this.currentGrid = this.initGrid(levelData);
                
                this.userAnswers = {};
                this.filledCells = 0;
                
                this.totalCells = 0;
                for (let r = 1; r <= levelData.gridSize.rows; r++) {
                    for (let c = 1; c <= levelData.gridSize.cols; c++) {
                        if (this.currentGrid[r][c].type === 'input' && !this.currentGrid[r][c].isPreset) {
                            this.totalCells++;
                        }
                    }
                }
                
                this.selectedCell = null;
                this.selectedCandidate = null;
                this.usedCandidates = new Set();
                this.candidateToCell = new Map();
                
                this.shuffledCandidates = this.shuffleArray([...levelData.candidateWords]);
                
                if (levelIndex === 0 && !this.gameStarted) {
                    this.gameStarted = true;
                    this.startTime = Date.now();
                    this.startTimer();
                }
            },
            
            shuffleArray: function(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            },
            
            initGrid: function(levelData) {
                const { rows, cols } = levelData.gridSize;
                const grid = [];
                
                for (let r = 1; r <= rows; r++) {
                    grid[r] = [];
                    for (let c = 1; c <= cols; c++) {
                        grid[r][c] = {
                            type: 'blank',
                            correctAnswer: '',
                            isPreset: false,
                            wordIds: [],
                            wordDirections: []
                        };
                    }
                }
                
                levelData.words.forEach(word => {
                    word.cells.forEach(cell => {
                        const { row, col, char, isPreset } = cell;
                        
                        grid[row][col].type = 'input';
                        grid[row][col].correctAnswer = char;
                        if (isPreset) {
                            grid[row][col].isPreset = true;
                        }
                        grid[row][col].wordIds.push(word.id);
                        grid[row][col].wordDirections.push(word.direction);
                    });
                });
                
                return grid;
            },
            
            // ä¿®å¤ï¼šä½¿ç”¨setIntervalï¼Œæ¯16msæ›´æ–°ä¸€æ¬¡ï¼ˆçº¦60fpsï¼‰ï¼Œç¡®ä¿æ˜¾ç¤ºå¹³æ»‘
            startTimer: function() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.startTime = Date.now();
                this.totalMilliseconds = 0;
                
                // ç«‹å³æ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
                this.updateTimerDisplay();
                
                // æ¯16æ¯«ç§’æ›´æ–°ä¸€æ¬¡ï¼ˆçº¦60fpsï¼‰ï¼Œç¡®ä¿æ˜¾ç¤ºå¹³æ»‘
                this.timerInterval = setInterval(() => {
                    this.updateTimerDisplay();
                }, 16); // 16ms â‰ˆ 60fps
            },
            
            // ä¿®å¤ï¼šå®æ—¶æ›´æ–°æ˜¾ç¤ºï¼Œä¸ä½¿ç”¨èŠ‚æµ
            updateTimerDisplay: function() {
                if (!this.startTime) return;
                
                const now = Date.now();
                this.totalMilliseconds = now - this.startTime;
                
                // å®æ—¶æ›´æ–°æ˜¾ç¤ºï¼Œä¸èŠ‚æµ
                const totalSeconds = this.totalMilliseconds / 1000;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = Math.floor(totalSeconds % 60);
                const ms = Math.floor(this.totalMilliseconds % 1000);
                
                const timerElement = document.getElementById('totalTimer');
                if (timerElement) {
                    timerElement.textContent = `æ€»ç”¨æ—¶: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                }
            },
            
            // æ ¼å¼åŒ–æ—¶é—´ï¼ˆæ˜¾ç¤º3ä½æ¯«ç§’ï¼‰
            formatTime: function(milliseconds) {
                const totalSeconds = milliseconds / 1000;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = Math.floor(totalSeconds % 60);
                const ms = Math.floor(milliseconds % 1000);
                
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            },
            
            // å°†æ¯«ç§’è½¬æ¢ä¸ºç§’ï¼ˆå°æ•°ï¼‰
            millisecondsToSeconds: function(milliseconds) {
                return milliseconds / 1000;
            },
            
            stopTimer: function() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                // ç¡®ä¿æœ€ç»ˆæ—¶é—´æ˜¾ç¤ºå‡†ç¡®
                this.updateTimerDisplay();
            },
            
            endGame: function() {
                this.gameEnded = true;
                this.endTime = Date.now();
                this.stopTimer();
            },
            
            selectCell: function(row, col) {
                const cellData = this.currentGrid[row][col];
                
                if (cellData.type !== 'input' || cellData.isPreset) {
                    this.selectedCell = null;
                    return false;
                }
                
                if (this.selectedCell && this.selectedCell.row === row && this.selectedCell.col === col) {
                    this.selectedCell = null;
                    return false;
                }
                
                if (this.selectedCell) {
                    const key1 = `${this.selectedCell.row}-${this.selectedCell.col}`;
                    const key2 = `${row}-${col}`;
                    const char1 = this.userAnswers[key1];
                    const char2 = this.userAnswers[key2];
                    
                    if (char1 && char2) {
                        const success = this.swapCells(this.selectedCell.row, this.selectedCell.col, row, col);
                        this.selectedCell = null;
                        return success;
                    }
                    else if (char1 && !char2) {
                        const success = this.moveCell(this.selectedCell.row, this.selectedCell.col, row, col);
                        this.selectedCell = null;
                        return success;
                    }
                    else if (!char1 && char2) {
                        const success = this.moveCell(row, col, this.selectedCell.row, this.selectedCell.col);
                        this.selectedCell = null;
                        return success;
                    }
                    else {
                        this.selectedCell = { row, col };
                        return true;
                    }
                }
                
                this.selectedCell = { row, col };
                return true;
            },
            
            selectCandidate: function(char) {
                if (this.selectedCandidate === char) {
                    this.selectedCandidate = null;
                    return false;
                }
                
                this.selectedCandidate = char;
                return true;
            },
            
            fillSelectedCell: function(char) {
                if (!this.selectedCell) {
                    return false;
                }
                
                const { row, col } = this.selectedCell;
                return this.fillCell(row, col, char);
            },
            
            fillCell: function(row, col, char) {
                const key = `${row}-${col}`;
                const cellData = this.currentGrid[row][col];
                
                if (cellData.type !== 'input' || cellData.isPreset) {
                    return false;
                }
                
                if (this.usedCandidates.has(char) && char !== this.userAnswers[key]) {
                    return false;
                }
                
                const existingChar = this.userAnswers[key];
                if (existingChar) {
                    this.removeCell(row, col);
                }
                
                this.userAnswers[key] = char;
                this.filledCells++;
                
                this.usedCandidates.add(char);
                
                this.candidateToCell.set(char, { row, col });
                
                return true;
            },
            
            removeCell: function(row, col) {
                const key = `${row}-${col}`;
                const cellData = this.currentGrid[row][col];
                
                if (cellData.type !== 'input' || cellData.isPreset) {
                    return false;
                }
                
                const char = this.userAnswers[key];
                if (!char) return false;
                
                delete this.userAnswers[key];
                this.filledCells--;
                
                this.usedCandidates.delete(char);
                
                this.candidateToCell.delete(char);
                
                return true;
            },
            
            clearSelectedCell: function(char) {
                if (!this.selectedCell) {
                    return false;
                }
                
                const { row, col } = this.selectedCell;
                const key = `${row}-${col}`;
                const cellData = this.currentGrid[row][col];
                
                if (cellData.type !== 'input' || cellData.isPreset) {
                    return false;
                }
                
                const cellChar = this.userAnswers[key];
                if (!cellChar) return false;
                
                if (cellChar !== char) {
                    return false;
                }
                
                this.removeCell(row, col);
                return true;
            },
            
            swapCells: function(row1, col1, row2, col2) {
                const key1 = `${row1}-${col1}`;
                const key2 = `${row2}-${col2}`;
                const char1 = this.userAnswers[key1];
                const char2 = this.userAnswers[key2];
                
                if (!char1 || !char2) {
                    return false;
                }
                
                if (char1 === char2) {
                    return true;
                }
                
                this.userAnswers[key1] = char2;
                this.userAnswers[key2] = char1;
                
                this.candidateToCell.set(char1, { row: row2, col: col2 });
                this.candidateToCell.set(char2, { row: row1, col: col1 });
                
                return true;
            },
            
            moveCell: function(fromRow, fromCol, toRow, toCol) {
                const fromKey = `${fromRow}-${fromCol}`;
                const toKey = `${toRow}-${toCol}`;
                const char = this.userAnswers[fromKey];
                
                if (!char || this.userAnswers[toKey]) {
                    return false;
                }
                
                this.userAnswers[toKey] = char;
                delete this.userAnswers[fromKey];
                
                this.candidateToCell.set(char, { row: toRow, col: toCol });
                
                return true;
            },
            
            checkLevelAnswers: function() {
                let allCorrect = true;
                let incorrectCells = [];
                
                if (this.filledCells < this.totalCells) {
                    return { 
                        allFilled: false, 
                        allCorrect: false, 
                        message: "å¯†ç å°šæœªå®Œå…¨ç ´è§£ï¼Œè¿˜æœ‰ç©ºæ ¼æœªå¡«å“¦~",
                        incorrectCells: []
                    };
                }
                
                for (let r = 1; r <= gameLevels[this.currentLevel].gridSize.rows; r++) {
                    for (let c = 1; c <= gameLevels[this.currentLevel].gridSize.cols; c++) {
                        const cellData = this.currentGrid[r][c];
                        if (cellData.type === 'input' && !cellData.isPreset) {
                            const key = `${r}-${c}`;
                            const userAnswer = this.userAnswers[key] || '';
                            const correctAnswer = cellData.correctAnswer;
                            
                            if (userAnswer !== correctAnswer) {
                                allCorrect = false;
                                incorrectCells.push({ row: r, col: c });
                            }
                        }
                    }
                }
                
                if (!allCorrect) {
                    return { 
                        allFilled: true, 
                        allCorrect: false, 
                        message: "å¯†ç ç ´è§£æœ‰è¯¯ï¼Œå†æ£€æŸ¥ä¸€ä¸‹å§~",
                        incorrectCells: incorrectCells
                    };
                }
                
                return { 
                    allFilled: true, 
                    allCorrect: true, 
                    message: "æ­å–œï¼å¯†ç æ­£ç¡®ï¼å¯ä»¥è§£é”ä¸‹ä¸€å…³ï¼",
                    incorrectCells: []
                };
            },
            
            nextLevel: function() {
                this.levelsCompleted++;
                
                if (this.currentLevel < gameLevels.length - 1) {
                    return true;
                } else {
                    this.endGame();
                    return false;
                }
            }
        };

        // ============================
        // Airtable API å‡½æ•°
        // ============================
        const AirtableAPI = {
            // æäº¤æˆç»©åˆ°Airtable
            async submitScore(name, timeInMilliseconds) {
                try {
                    const timeInSeconds = timeInMilliseconds / 1000;
                    const timeText = gameState.formatTime(timeInMilliseconds);
                    
                    const url = `${AIRTABLE_CONFIG.API_URL}/${AIRTABLE_CONFIG.BASE_ID}/${encodeURIComponent(AIRTABLE_CONFIG.TABLE_NAME)}`;
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            records: [
                                {
                                    fields: {
                                        'Name': name,
                                        'Time': timeInSeconds,
                                        'Timetext': timeText,
                                        'Date': new Date().toISOString()
                                    }
                                }
                            ]
                        })
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`æäº¤å¤±è´¥: ${response.status} - ${errorText}`);
                    }
                    
                    const data = await response.json();
                    console.log('æˆç»©æäº¤æˆåŠŸ:', data);
                    return { success: true, data };
                } catch (error) {
                    console.error('æäº¤æˆç»©å¤±è´¥:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // è·å–æ’è¡Œæ¦œæ•°æ®
            async getLeaderboard() {
                try {
                    const url = `${AIRTABLE_CONFIG.API_URL}/${AIRTABLE_CONFIG.BASE_ID}/${encodeURIComponent(AIRTABLE_CONFIG.TABLE_NAME)}?sort[0][field]=Time&sort[0][direction]=asc&maxRecords=100`;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`è·å–å¤±è´¥: ${response.status} - ${errorText}`);
                    }
                    
                    const data = await response.json();
                    const records = data.records;
                    
                    if (!records || records.length === 0) {
                        return { success: true, data: [] };
                    }
                    
                    const playerBestScores = {};
                    
                    records.forEach(record => {
                        const fields = record.fields;
                        const name = fields.Name;
                        let time = fields.Time;
                        
                        let timeInMilliseconds;
                        if (time === Math.floor(time)) {
                            timeInMilliseconds = time * 1000;
                        } else {
                            timeInMilliseconds = time * 1000;
                        }
                        
                        if (name && time !== null && time !== undefined) {
                            if (!playerBestScores[name] || timeInMilliseconds < playerBestScores[name].timeInMilliseconds) {
                                playerBestScores[name] = {
                                    Name: name,
                                    Time: time,
                                    timeInMilliseconds: timeInMilliseconds,
                                    Timetext: fields.Timetext || gameState.formatTime(timeInMilliseconds),
                                    Date: fields.Date
                                };
                            }
                        }
                    });
                    
                    const bestScoresArray = Object.values(playerBestScores);
                    
                    bestScoresArray.sort((a, b) => {
                        if (a.timeInMilliseconds !== b.timeInMilliseconds) {
                            return a.timeInMilliseconds - b.timeInMilliseconds;
                        }
                        return new Date(a.Date) - new Date(b.Date);
                    });
                    
                    return { 
                        success: true, 
                        data: bestScoresArray.slice(0, 20).map((item, index) => ({
                            id: `best_${index}`,
                            fields: item
                        }))
                    };
                } catch (error) {
                    console.error('è·å–æ’è¡Œæ¦œå¤±è´¥:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // æ˜¾ç¤ºæ’è¡Œæ¦œ
            async displayLeaderboard() {
                const container = document.getElementById('leaderboardContainer');
                
                container.innerHTML = '<div class="loader"></div><p style="text-align: center;">æ­£åœ¨åŠ è½½æ’è¡Œæ¦œ...</p>';
                
                const result = await this.getLeaderboard();
                
                if (!result.success) {
                    let errorMessage = result.error;
                    
                    if (result.error.includes('403')) {
                        errorMessage = 'è®¿é—®æƒé™è¢«æ‹’ç»ã€‚è¯·æ£€æŸ¥API Keyæ˜¯å¦æ­£ç¡®ã€‚';
                    } else if (result.error.includes('404')) {
                        errorMessage = 'æœªæ‰¾åˆ°è¡¨ã€‚è¯·æ£€æŸ¥è¡¨åæ˜¯å¦æ­£ç¡®ï¼šgamerank';
                    } else if (result.error.includes('401')) {
                        errorMessage = 'è®¤è¯å¤±è´¥ã€‚API Keyå¯èƒ½æ— æ•ˆæˆ–å·²è¿‡æœŸã€‚';
                    }
                    
                    container.innerHTML = `
                        <h3 style="text-align: center; color: #4a6fa5; margin-top: 20px;">ğŸ† æ’è¡Œæ¦œ</h3>
                        <p style="text-align: center; color: #e74c3c;">åŠ è½½å¤±è´¥: ${errorMessage}</p>
                        <p style="text-align: center; font-size: 0.9rem; color: #666;">è¯·ç¡®ä¿Airtableè¡¨ä¸­æœ‰æ­£ç¡®çš„å­—æ®µï¼šName, Time, Timetext, Date</p>
                        <div class="button-container">
                            <button id="retryLeaderboardBtn">é‡è¯•</button>
                            <button id="hideLeaderboardBtn">éšè—æ’è¡Œæ¦œ</button>
                        </div>
                    `;
                    
                    document.getElementById('retryLeaderboardBtn').addEventListener('click', () => {
                        this.displayLeaderboard();
                    });
                    
                    document.getElementById('hideLeaderboardBtn').addEventListener('click', () => {
                        showLeaderboardButton();
                    });
                    
                    return;
                }
                
                const records = result.data;
                
                if (!records || records.length === 0) {
                    container.innerHTML = `
                        <h3 style="text-align: center; color: #4a6fa5; margin-top: 20px;">ğŸ† æ’è¡Œæ¦œ</h3>
                        <p style="text-align: center;">æš‚æ— æˆç»©ï¼Œå¿«æ¥æˆä¸ºç¬¬ä¸€åå§ï¼</p>
                        <div class="button-container">
                            <button id="hideLeaderboardBtn">éšè—æ’è¡Œæ¦œ</button>
                        </div>
                    `;
                    
                    document.getElementById('hideLeaderboardBtn').addEventListener('click', () => {
                        showLeaderboardButton();
                    });
                    
                    return;
                }
                
                let html = '<h3 style="text-align: center; color: #4a6fa5; margin-top: 20px;">ğŸ† æ’è¡Œæ¦œ</h3>';
                html += '<table id="leaderboard">';
                html += '<thead><tr><th>æ’å</th><th>æ˜µç§°</th><th>ç”¨æ—¶</th><th>æŒ‘æˆ˜æ—¶é—´</th></tr></thead>';
                html += '<tbody>';
                
                let currentRank = 1;
                let previousTime = null;
                let previousRank = 0;
                
                records.forEach((record, index) => {
                    const fields = record.fields;
                    
                    let timeStr;
                    if (fields.Timetext) {
                        timeStr = fields.Timetext;
                    } else if (fields.timeInMilliseconds) {
                        timeStr = gameState.formatTime(fields.timeInMilliseconds);
                    } else if (fields.Time) {
                        timeStr = gameState.formatTime(fields.Time * 1000);
                    } else {
                        timeStr = '--:--.--';
                    }
                    
                    const date = new Date(fields.Date);
                    const dateStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                    
                    let displayRank = currentRank;
                    if (previousTime !== null && fields.timeInMilliseconds === previousTime) {
                        displayRank = previousRank;
                    } else {
                        previousRank = currentRank;
                        displayRank = currentRank;
                    }
                    
                    previousTime = fields.timeInMilliseconds;
                    currentRank++;
                    
                    let rowClass = '';
                    if (displayRank === 1) rowClass = 'style="background-color: #fffacd;"';
                    else if (displayRank === 2) rowClass = 'style="background-color: #f0f0f0;"';
                    else if (displayRank === 3) rowClass = 'style="background-color: #ffebcd;"';
                    
                    html += `<tr ${rowClass}>`;
                    html += `<td>${displayRank}</td>`;
                    html += `<td>${fields.Name}</td>`;
                    html += `<td>${timeStr}</td>`;
                    html += `<td>${dateStr}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                
                html += `
                    <div class="button-container">
                        <button id="refreshLeaderboardBtn">åˆ·æ–°æ’è¡Œæ¦œ</button>
                        <button id="hideLeaderboardBtn">éšè—æ’è¡Œæ¦œ</button>
                    </div>
                `;
                
                container.innerHTML = html;
                
                document.getElementById('refreshLeaderboardBtn').addEventListener('click', () => {
                    this.displayLeaderboard();
                });
                
                document.getElementById('hideLeaderboardBtn').addEventListener('click', () => {
                    showLeaderboardButton();
                });
            }
        };

        // ============================
        // DOMå…ƒç´ å’Œåˆå§‹åŒ–
        // ============================
        let crosswordTable, gameStatus, totalTimer, completionTime;
        let candidateWords, levelTitle, gridTitle;
        let nextLevelBtn, checkBtn, resetBtn;
        let levelIndicator;
        let nicknameModal, nicknameInput, submitScoreBtn, cancelScoreBtn;
        let viewLeaderboardBtn;

        // åˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', function() {
            crosswordTable = document.getElementById('crosswordTable');
            gameStatus = document.getElementById('gameStatus');
            totalTimer = document.getElementById('totalTimer');
            completionTime = document.getElementById('completionTime');
            candidateWords = document.getElementById('candidateWords');
            levelTitle = document.getElementById('levelTitle');
            gridTitle = document.getElementById('gridTitle');
            levelIndicator = document.getElementById('levelIndicator');
            
            nextLevelBtn = document.getElementById('nextLevelBtn');
            checkBtn = document.getElementById('checkBtn');
            resetBtn = document.getElementById('resetBtn');
            
            nicknameModal = document.getElementById('nicknameModal');
            nicknameInput = document.getElementById('nicknameInput');
            submitScoreBtn = document.getElementById('submitScoreBtn');
            cancelScoreBtn = document.getElementById('cancelScoreBtn');
            
            initializeGame();
            setupEventListeners();
            updateLevelIndicator();
            
            showLeaderboardButton();
        });

        // æ˜¾ç¤ºæ’è¡Œæ¦œæŒ‰é’®
        function showLeaderboardButton() {
            const container = document.getElementById('leaderboardContainer');
            container.innerHTML = `
                <button id="viewLeaderboardBtn">æŸ¥çœ‹æ’è¡Œæ¦œ</button>
            `;
            
            document.getElementById('viewLeaderboardBtn').addEventListener('click', () => {
                AirtableAPI.displayLeaderboard();
            });
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initializeGame() {
            gameState.currentLevel = 0;
            gameState.levelsCompleted = 0;
            gameState.gameStarted = false;
            gameState.gameEnded = false;
            gameState.startTime = null;
            gameState.endTime = null;
            gameState.totalMilliseconds = 0;
            
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            
            gameState.init(0);
            createGrid();
            createCandidateWords();
            
            levelTitle.textContent = gameLevels[0].title;
            gridTitle.textContent = "è¯·ä»ä¸‹æ–¹å¤‡é€‰å­—ä¸­é€‰æ‹©å¡«å…¥ç©ºæ ¼ä¸­";
            
            nextLevelBtn.style.display = 'none';
            checkBtn.style.display = 'flex';
            
            resetBtn.textContent = 'é‡ç½®æœ¬å…³';
            
            totalTimer.style.display = 'block';
            totalTimer.textContent = 'æ€»ç”¨æ—¶: 00:00.000';
            
            completionTime.style.display = 'none';
            
            gameStatus.textContent = 'è¯·é€‰æ‹©ç©ºæ ¼æˆ–å¤‡é€‰å­—';
            gameStatus.className = 'game-status info';
            
            gameStatus.classList.remove('celebrate');
            
            updateLevelIndicator();
            
            showLeaderboardButton();
        }

        // åˆ›å»ºç½‘æ ¼
        function createGrid() {
            const levelData = gameLevels[gameState.currentLevel];
            const { rows, cols } = levelData.gridSize;
            
            crosswordTable.innerHTML = '';
            
            for (let r = 1; r <= rows; r++) {
                const rowEl = document.createElement('tr');
                
                for (let c = 1; c <= cols; c++) {
                    const cellData = gameState.currentGrid[r][c];
                    const cellEl = document.createElement('td');
                    
                    if (cellData.type === 'blank') {
                        cellEl.className = 'blank-cell';
                    } 
                    else if (cellData.type === 'input') {
                        if (cellData.isPreset) {
                            cellEl.className = 'preset-cell';
                            cellEl.textContent = cellData.correctAnswer;
                        } 
                        else {
                            cellEl.className = 'input-cell';
                            cellEl.dataset.row = r;
                            cellEl.dataset.col = c;
                            
                            const key = `${r}-${c}`;
                            if (gameState.userAnswers[key]) {
                                cellEl.textContent = gameState.userAnswers[key];
                                cellEl.classList.add('filled');
                            }
                        }
                    }
                    
                    rowEl.appendChild(cellEl);
                }
                
                crosswordTable.appendChild(rowEl);
            }
            
            setupCellListeners();
        }

        // åˆ›å»ºå¤‡é€‰å­—
        function createCandidateWords() {
            candidateWords.innerHTML = '';
            
            gameState.shuffledCandidates.forEach(char => {
                const wordEl = document.createElement('div');
                wordEl.className = 'candidate-word';
                wordEl.textContent = char;
                wordEl.dataset.char = char;
                
                if (gameState.usedCandidates.has(char)) {
                    wordEl.classList.add('used');
                }
                
                if (gameState.selectedCandidate === char) {
                    wordEl.classList.add('selected');
                }
                
                candidateWords.appendChild(wordEl);
            });
            
            setupCandidateListeners();
        }

        // æ›´æ–°UIé€‰æ‹©çŠ¶æ€
        function updateSelectionUI() {
            const allCells = crosswordTable.querySelectorAll('.input-cell:not(.preset-cell)');
            allCells.forEach(cell => {
                cell.classList.remove('selected');
                
                if (gameState.selectedCell) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    if (gameState.selectedCell.row === row && gameState.selectedCell.col === col) {
                        cell.classList.add('selected');
                    }
                }
            });
            
            const allCandidates = candidateWords.querySelectorAll('.candidate-word');
            allCandidates.forEach(candidate => {
                candidate.classList.remove('selected');
                
                if (gameState.selectedCandidate === candidate.dataset.char) {
                    candidate.classList.add('selected');
                }
            });
            
            let statusText = '';
            
            if (gameState.selectedCell && gameState.selectedCandidate) {
                const { row, col } = gameState.selectedCell;
                const existingChar = gameState.userAnswers[`${row}-${col}`];
                if (existingChar) {
                    statusText = `å·²é€‰ä¸­æ ¼å­(${row},${col})ï¼Œå½“å‰æœ‰å­—"${existingChar}"ï¼Œå¤‡é€‰å­—"${gameState.selectedCandidate}"å·²é€‰ä¸­`;
                } else {
                    statusText = `å·²é€‰ä¸­æ ¼å­(${row},${col})ï¼Œå¤‡é€‰å­—"${gameState.selectedCandidate}"å·²é€‰ä¸­ï¼Œç‚¹å‡»ç¡®è®¤å¡«å…¥`;
                }
            } else if (gameState.selectedCell) {
                const { row, col } = gameState.selectedCell;
                const existingChar = gameState.userAnswers[`${row}-${col}`];
                if (existingChar) {
                    statusText = `å·²é€‰ä¸­æ ¼å­(${row},${col})ï¼Œå½“å‰æœ‰å­—"${existingChar}"ï¼Œå¯ç‚¹å‡»ç©ºç©ºæ ¼ç§»åŠ¨ï¼Œæˆ–ç‚¹å‡»å…¶ä»–å·²å¡«æ ¼å­äº¤æ¢`;
                } else {
                    statusText = `å·²é€‰ä¸­æ ¼å­(${row},${col})ï¼Œè¯·ç‚¹å‡»å¤‡é€‰å­—å¡«å…¥ï¼Œæˆ–ç‚¹å‡»å·²å¡«æ ¼å­äº¤æ¢/ç§»åŠ¨`;
                }
            } else if (gameState.selectedCandidate) {
                statusText = `å·²é€‰ä¸­å¤‡é€‰å­—"${gameState.selectedCandidate}"ï¼Œè¯·ç‚¹å‡»ç©ºæ ¼å¡«å…¥`;
            } else {
                statusText = 'è¯·é€‰æ‹©ç©ºæ ¼æˆ–å¤‡é€‰å­—';
            }
            
            gameStatus.textContent = statusText;
            gameStatus.className = 'game-status info';
        }

        // è®¾ç½®å•å…ƒæ ¼ç‚¹å‡»äº‹ä»¶
        function setupCellListeners() {
            const cells = crosswordTable.querySelectorAll('.input-cell:not(.preset-cell)');
            
            cells.forEach(cell => {
                cell.addEventListener('click', function() {
                    const row = parseInt(this.dataset.row);
                    const col = parseInt(this.dataset.col);
                    
                    if (gameState.selectedCandidate) {
                        const filled = gameState.fillCell(row, col, gameState.selectedCandidate);
                        
                        if (filled) {
                            this.textContent = gameState.selectedCandidate;
                            this.classList.add('filled');
                            
                            createCandidateWords();
                            
                            gameState.selectedCandidate = null;
                            gameState.selectedCell = null;
                            
                            gameStatus.textContent = `å·²å°†"${gameState.userAnswers[`${row}-${col}`]}"å¡«å…¥æ ¼å­(${row},${col})`;
                            gameStatus.className = 'game-status info';
                        } else {
                            gameStatus.textContent = 'å¡«å…¥å¤±è´¥ï¼Œè¯¥å¤‡é€‰å­—å¯èƒ½å·²è¢«ä½¿ç”¨';
                            gameStatus.className = 'game-status incorrect';
                        }
                    } else {
                        const selected = gameState.selectCell(row, col);
                        
                        if (selected && gameState.selectedCell === null) {
                            updateAllGridCells();
                            createCandidateWords();
                        }
                    }
                    
                    updateSelectionUI();
                });
            });
        }

        // æ›´æ–°æ‰€æœ‰ç½‘æ ¼å•å…ƒæ ¼çš„æ˜¾ç¤º
        function updateAllGridCells() {
            const levelData = gameLevels[gameState.currentLevel];
            const { rows, cols } = levelData.gridSize;
            
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    const cellData = gameState.currentGrid[r][c];
                    if (cellData.type === 'input' && !cellData.isPreset) {
                        const cellElement = crosswordTable.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
                        if (cellElement) {
                            const key = `${r}-${c}`;
                            const char = gameState.userAnswers[key];
                            
                            if (char) {
                                cellElement.textContent = char;
                                cellElement.classList.add('filled');
                            } else {
                                cellElement.textContent = '';
                                cellElement.classList.remove('filled');
                            }
                        }
                    }
                }
            }
        }

        // è®¾ç½®å¤‡é€‰å­—ç‚¹å‡»äº‹ä»¶
        function setupCandidateListeners() {
            const candidateElements = candidateWords.querySelectorAll('.candidate-word');
            
            candidateElements.forEach(element => {
                element.addEventListener('click', function() {
                    const char = this.dataset.char;
                    
                    if (this.classList.contains('used')) {
                        if (!gameState.selectedCell || 
                            (gameState.selectedCell && 
                             gameState.userAnswers[`${gameState.selectedCell.row}-${gameState.selectedCell.col}`] !== char)) {
                            
                            gameStatus.textContent = `"${char}"å·²è¢«ä½¿ç”¨ï¼Œä¸å¯é‡å¤é€‰æ‹©`;
                            gameStatus.className = 'game-status incorrect';
                            return;
                        }
                    }
                    
                    if (gameState.selectedCell) {
                        const { row, col } = gameState.selectedCell;
                        const existingChar = gameState.userAnswers[`${row}-${col}`];
                        
                        if (existingChar && existingChar === char) {
                            const cleared = gameState.clearSelectedCell(char);
                            
                            if (cleared) {
                                const cellElement = crosswordTable.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                                if (cellElement) {
                                    cellElement.textContent = '';
                                    cellElement.classList.remove('filled');
                                }
                                
                                createCandidateWords();
                                
                                gameState.selectedCell = null;
                                gameState.selectedCandidate = null;
                                
                                gameStatus.textContent = `å·²æ¸…ç©ºæ ¼å­(${row},${col})`;
                                gameStatus.className = 'game-status info';
                            }
                        } else {
                            const filled = gameState.fillSelectedCell(char);
                            
                            if (filled) {
                                const { row, col } = gameState.selectedCell;
                                const cellElement = crosswordTable.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                                if (cellElement) {
                                    cellElement.textContent = char;
                                    cellElement.classList.add('filled');
                                }
                                
                                createCandidateWords();
                                
                                gameState.selectedCell = null;
                                gameState.selectedCandidate = null;
                                
                                gameStatus.textContent = `å·²å°†"${char}"å¡«å…¥æ ¼å­(${row},${col})`;
                                gameStatus.className = 'game-status info';
                            } else {
                                gameStatus.textContent = 'å¡«å…¥å¤±è´¥ï¼Œè¯·é‡è¯•';
                                gameStatus.className = 'game-status incorrect';
                            }
                        }
                    } else {
                        const selected = gameState.selectCandidate(char);
                    }
                    
                    updateSelectionUI();
                });
            });
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            checkBtn.addEventListener('click', checkAnswers);
            
            nextLevelBtn.addEventListener('click', goToNextLevel);
            
            resetBtn.addEventListener('click', resetGame);
            
            submitScoreBtn.addEventListener('click', async () => {
                const nickname = nicknameInput.value.trim();
                if (!nickname) {
                    alert('è¯·è¾“å…¥æ˜µç§°ï¼');
                    return;
                }
                
                submitScoreBtn.disabled = true;
                submitScoreBtn.textContent = 'æäº¤ä¸­...';
                
                const result = await AirtableAPI.submitScore(nickname, gameState.totalMilliseconds);
                
                if (result.success) {
                    nicknameModal.style.display = 'none';
                    alert('æˆç»©å·²æˆåŠŸæäº¤åˆ°æ’è¡Œæ¦œï¼');
                    
                    submitScoreBtn.disabled = false;
                    submitScoreBtn.textContent = 'æäº¤æˆç»©';
                    
                    AirtableAPI.displayLeaderboard();
                } else {
                    alert('æäº¤å¤±è´¥: ' + result.error);
                    submitScoreBtn.disabled = false;
                    submitScoreBtn.textContent = 'æäº¤æˆç»©';
                }
            });
            
            cancelScoreBtn.addEventListener('click', () => {
                nicknameModal.style.display = 'none';
                
                submitScoreBtn.disabled = false;
                submitScoreBtn.textContent = 'æäº¤æˆç»©';
            });
        }

        // æ£€æŸ¥ç­”æ¡ˆ
        function checkAnswers() {
            const result = gameState.checkLevelAnswers();
            
            if (!result.allFilled) {
                gameStatus.textContent = result.message;
                gameStatus.className = 'game-status incorrect';
            } else if (!result.allCorrect) {
                gameStatus.textContent = result.message;
                gameStatus.className = 'game-status incorrect';
                
                result.incorrectCells.forEach(cell => {
                    const { row, col } = cell;
                    const cellElement = crosswordTable.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cellElement) {
                        cellElement.style.boxShadow = 'inset 0 0 0 2px #e74c3c';
                        
                        setTimeout(() => {
                            cellElement.style.boxShadow = '';
                        }, 2000);
                    }
                });
            } else {
                gameStatus.textContent = result.message;
                gameStatus.className = 'game-status correct';
                
                if (gameState.currentLevel === 3) {
                    gameState.stopTimer();
                    showCompletionScreen();
                } else {
                    nextLevelBtn.style.display = 'flex';
                    checkBtn.style.display = 'none';
                }
                
                updateLevelIndicator();
            }
        }

        // è¿›å…¥ä¸‹ä¸€å…³
        function goToNextLevel() {
            const hasNextLevel = gameState.nextLevel();
            
            if (hasNextLevel) {
                gameState.init(gameState.currentLevel + 1);
                createGrid();
                createCandidateWords();
                
                levelTitle.textContent = gameLevels[gameState.currentLevel].title;
                gridTitle.textContent = "è¯·ä»ä¸‹æ–¹å¤‡é€‰å­—ä¸­é€‰æ‹©å¡«å…¥ç©ºæ ¼ä¸­";
                
                nextLevelBtn.style.display = 'none';
                checkBtn.style.display = 'flex';
                
                gameStatus.textContent = 'è¯·é€‰æ‹©ç©ºæ ¼æˆ–å¤‡é€‰å­—';
                gameStatus.className = 'game-status info';
                
                updateLevelIndicator();
            } else {
                gameState.stopTimer();
                showCompletionScreen();
            }
        }

        // æ˜¾ç¤ºå®Œæˆç”»é¢
        function showCompletionScreen() {
            gameStatus.textContent = `æ­å–œï¼ä½ å·²æˆåŠŸè§£é”æ‰€æœ‰æ–‡åŒ–å¯†ç ï¼æ€»ç”¨æ—¶: ${gameState.formatTime(gameState.totalMilliseconds)}`;
            gameStatus.className = 'game-status correct';
            
            completionTime.textContent = `æ¸¸æˆå®Œæˆæ€»ç”¨æ—¶: ${gameState.formatTime(gameState.totalMilliseconds)}`;
            completionTime.style.display = 'block';
            
            nextLevelBtn.style.display = 'none';
            checkBtn.style.display = 'none';
            
            resetBtn.textContent = 'é‡æ–°æŒ‘æˆ˜';
            
            updateLevelIndicator();
            
            gameStatus.classList.add('celebrate');
            
            setTimeout(() => {
                showNicknameModal();
            }, 1500);
        }

        // æ˜¾ç¤ºæ˜µç§°è¾“å…¥å¼¹çª—
        function showNicknameModal() {
            nicknameInput.value = '';
            
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'æäº¤æˆç»©';
            
            nicknameModal.style.display = 'flex';
            nicknameInput.focus();
        }

        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            if (resetBtn.textContent === 'é‡æ–°æŒ‘æˆ˜') {
                if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æŒ‘æˆ˜å—ï¼Ÿæ‰€æœ‰å…³å¡è¿›åº¦å’Œè®¡æ—¶å°†è¢«æ¸…é™¤ã€‚')) {
                    initializeGame();
                }
            } else {
                if (confirm('ç¡®å®šè¦é‡ç½®å½“å‰å…³å¡å—ï¼Ÿæ‰€æœ‰å·²å¡«å†™çš„ç­”æ¡ˆå°†è¢«æ¸…é™¤ã€‚')) {
                    gameState.init(gameState.currentLevel);
                    createGrid();
                    createCandidateWords();
                    
                    gameStatus.textContent = 'è¯·é€‰æ‹©ç©ºæ ¼æˆ–å¤‡é€‰å­—';
                    gameStatus.className = 'game-status info';
                    
                    nextLevelBtn.style.display = 'none';
                    checkBtn.style.display = 'flex';
                }
            }
        }

        // æ›´æ–°å…³å¡æŒ‡ç¤ºå™¨
        function updateLevelIndicator() {
            const dots = levelIndicator.querySelectorAll('.level-dot');
            
            dots.forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                
                if (index === gameState.currentLevel) {
                    dot.classList.add('active');
                }
                
                if (index < gameState.levelsCompleted) {
                    dot.classList.add('completed');
                }
            });
        }
    </script>
</body>
</html>